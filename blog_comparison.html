<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ethan Shea and James Wilcox" />
  <meta name="dcterms.date" content="2018-03-28" />
  <title>Encoding Techniques in Verified Serializers</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="blog-post.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta charset="UTF-8">
  <script type='text/javascript' src="jquery-2.1.1.js"></script>
  <link rel="stylesheet" href="jquery-ui-1.11.1.custom/jquery-ui.min.css" />
  <script type='text/javascript' src="jquery-ui-1.11.1.custom/jquery-ui.min.js"></script>
</head>
<body>
<header>
<h1 class="title">Encoding Techniques in Verified Serializers</h1>
<p class="author">Ethan Shea and James Wilcox</p>
<p class="date">March 28, 2018</p>
</header>
<p>Serialization converts in-memory data to an external representation, typically a sequence of bytes, which is then ready to be stored on disk or sent over the network.</p>
<p>This post describes Cheerios, a verified library for serialization in Coq. Cheerios uses typeclasses to make it easy to create new serializers by composing existing serializers, such that the correctness proofs also compose. We first give an overview of the core definitions of Cheerios and show how to build simple serializers for booleans, natural numbers, and pairs. Then, we describe two generic strategies for serializing recursive “container-like” types, such as lists and trees, and discuss the tradeoffs in proof effort between the strategies. A recurring theme is the challenge of expressing decoders via <em>structural recursion</em>, so that they are accepted by Coq’s termination checker.</p>
<p>This post is generated from a literate Coq <a href="">file</a>, which we encourage you to step through to see the full details.</p>
<h2 id="defining-serialization">Defining Serialization</h2>
<p>We start by deriving Cheerios’ representation of serializers, deserializers, and their specifications from first principles. Rougly speaking, our desired specification is that deserialization is an inverse of serialization, so that if you start with a value <code>v</code> and serialize it, then deserializing the resulting representation gives <code>v</code> again.</p>
<p>Cheerios represents serialized data as a list of booleans, so that a serializer for values of type <code>A</code> is a function of type <code>A -&gt; list bool</code>. To illustrate serialization consider the following simple example.</p>
<pre><code><span style='color:#a020f0'>Inductive</span> <span style='color:#3b10ff'>medal</span> := Gold | Silver | Bronze.
</code></pre>
<p>A serializer for this type is a function of type <code>metal -&gt; list bool</code>. There are several ways of implementing such a function, with some tradeoffs we will explore later, but for now we just pick a simple strategy.</p>
<pre><code><span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>medal_serialize</span> (m: medal) : list bool :=
  <span style='color:#228b22'>match</span> m <span style='color:#228b22'>with</span>
  | Gold =&gt; [true; true]
  | Silver =&gt; [true; false]
  | Bronze =&gt; [false]
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>How do we know whether we’ve implemented a good serializer or not? Intuitively, it would be bad if, for example, two different values mapped to the same sequence of bits, because then the deserializer will not be able to distinguish them. So we might summarize by saying that a serializer is good if there is some deserializer that can correctly decode all serialized values.</p>
<p>To formalize this idea, we first need to settle on a type for deserializers. Since our goal is in some sense to invert the serializer, the natural first thought would be to have a deserializer of type <code>list bool -&gt; A</code>. Then our specification would say that the deserializer really is the inverse of the serializer, i.e.,</p>
<pre><code>    <span style='color:#228b22'>forall</span> <span style='color:#a0522d'>a</span>, deserialize (serialize a) = a.
</code></pre>
<p>However, this quickly runs into problems when we try to continue our example.</p>
<pre><code><span style='color:#a020f0'>Fail</span> <span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>medal_deserialize</span> (bools: list bool) : medal :=
  <span style='color:#228b22'>match</span> bools <span style='color:#228b22'>with</span>
  | [true; true] =&gt; Gold
  | [true; false] =&gt; Silver
  | [false] =&gt; Bronze
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>Coq reports that the pattern maching above is not exhaustive, since, for example, we don’t say what should happen if we deserialize the empty list. In other words, the type <code>list bool -&gt; medal</code> is asking us to produce a <code>medal</code> for <em>every</em> list of booleans, even those that are not a valid output of the serializer. In those cases, we might like the deserializer to return an error, which we can encode using an <code>option</code> type.</p>
<p>That gives us our second (but still not quite right) guess at a type for deserializers, namely <code>list bool -&gt; option A</code>. Our notion of “inverse” also needs to be generalized to this setting. We do so by requring that the deserializer succeed on all serialized values; in other words,</p>
<pre><code>    <span style='color:#228b22'>forall</span> <span style='color:#a0522d'>a</span>, deserialize (serialize a) = Some a.
</code></pre>
<p>We can now implement the deserializer for <code>medal</code> in a way that Coq accepts.</p>
<pre><code><span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>medal_deserialize_second_attempt</span> bools : option medal :=
  <span style='color:#228b22'>match</span> bools <span style='color:#228b22'>with</span>
  | [true; true] =&gt; Some Gold
  | [true; false] =&gt; Some Silver
  | [false] =&gt; Some Bronze
  | _ =&gt; None
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>We can even prove that the serializer and deserializer for <code>medal</code> satisfy the specification.</p>
<pre><code><span style='color:#a020f0'>Lemma</span> <span style='color:#3b10ff'>medal_serialize_deserialize_inverse</span> :
  <span style='color:#228b22'>forall</span> <span style='color:#a0522d'>m</span>,
    medal_deserialize_second_attempt (medal_serialize m) = Some m.
<span style='color:#a020f0'>Proof</span>.
  <span style='color:#00008b'>destruct</span> m; <span style='color:#ff0000'>reflexivity</span>.
<span style='color:#a020f0'>Qed</span>.
</code></pre>
<p>So far so good.</p>
<p>Now suppose we want to serialize two values of type <code>medal</code> back to back. No problem, just serialize them individually and concatenate the results together into one big list. How should we deserialize such a thing? It would be nice to reuse the deserializer for a single medal, just like we were able to reuse the serializer, but it’s not clear how.</p>
<pre><code><span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>medal_serialize_pair</span> (medals: medal * medal) :=
  medal_serialize (fst medals) ++ medal_serialize (snd medals).

<span style='color:#a020f0'>Fail</span>
<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>medal_deserialize_pair</span> bools : option (medal * medal) :=
  (medal_deserialize1 bools, medal_deserialize1 (* hmmm *)).
</code></pre>
<p>Our type for deserializers implicitly means that the deserializer “consumes” the entire list of booleans. So there’s no clear candidate for what to pass into the second call.</p>
<p>We fix this problem in our third (and final!) candidate for the type of a deserializer, which needs to communicate how much of the list was used back to the caller. It does so be returning the unused suffix of the input list. It’s still possible that the whole operation can fail, so the type ends up being</p>
<pre><code>    list bool -&gt; option (A * list bool).</code></pre>
<p>It’s relatively straightforward to update our <code>medal</code> deserializer to return the unused portion of the input list.</p>
<pre><code><span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>medal_deserialize</span> bools : option (medal * list bool) :=
  <span style='color:#228b22'>match</span> bools <span style='color:#228b22'>with</span>
  | true :: true :: bools =&gt; Some (Gold, bools)
  | true :: false :: bools =&gt; Some (Silver, bools)
  | false :: bools =&gt; Some (Bronze, bools)
  | _ =&gt; None
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>We still need to come up with a the notion of “inverse” that makes sense in the presence of unused portions of the list. First, let’s take a moment to write down our types for serializers and deserializers in general.</p>
<pre><code><span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>serializer</span> (A: <span style='color:#228b22'>Type</span>) := A -&gt; list bool.

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>deserializer</span> (A: <span style='color:#228b22'>Type</span>) :=
  list bool -&gt; option (A * list bool).
</code></pre>
<p>For the correctness property, perhaps the first type-correct thing that comes to mind is</p>
<pre><code>    <span style='color:#228b22'>forall</span> <span style='color:#a0522d'>a</span>, deserialize (serialize a) = Some (a, []).
</code></pre>
<p>This is a good property, but it is not enough to handle the problem of deserializing two medals back to back. We can attempt to handle this as follows:</p>
<pre><code>    <span style='color:#228b22'>forall</span> <span style='color:#a0522d'>a</span> <span style='color:#a0522d'>b</span>,
      deserialize (serialize a ++ serialize b) =
      Some (a, serialize b).
</code></pre>
<p>This handles two objects, but only in an ad hoc, specialized way. Considering that we want to handle the case of a single object, or arbitrarily many objects all with a single specification, we are led to generalize over the suffix:</p>
<pre><code>    <span style='color:#228b22'>forall</span> <span style='color:#a0522d'>a</span> <span style='color:#a0522d'>bools</span>,
      deserialize (serialize a ++ bools) = Some (a, bools).
</code></pre>
<p>Notice two points about this specification. First, it only restricts the behavior of the deserializer on lists that start with the output of the serializer. On any list not of this form, the deserializer is free to fail or return a garbage element of type <code>A</code>. Second, the deserializer is in some sense parametric in the suffix of the list after the serialized data: it is required to uniformly pass the suffix through. This is what makes it easy to compose arbitrary deserializers together to process complex data.</p>
<p>We codify this specification with the following definition.</p>
<pre><code><span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>ser_deser_spec</span> A
           (s : serializer A) (d : deserializer A) :=
  <span style='color:#228b22'>forall</span> <span style='color:#a0522d'>a</span> <span style='color:#a0522d'>bools</span>,
    d (s a ++ bools) = Some (a, bools).
</code></pre>
<p>Wrapping this up in a class gives us the following definition which includes the following three things: a serializer, a deserializer, and a proof of correctness.</p>
<pre><code><span style='color:#a020f0'>Class</span> <span style='color:#3b10ff'>Serializer</span> (A : <span style='color:#228b22'>Type</span>) : <span style='color:#228b22'>Type</span> := {
    serialize : A -&gt; list bool;
    deserialize : list bool -&gt; option (A * list bool);
    ser_deser_identity : ser_deser_spec A serialize deserialize
}.
</code></pre>
<p>In general, the correctness proofs tend to be straightforward and repetitive, but this first one is included here to show the structure. Concretely this becomes:</p>
<pre><code><span style='color:#a020f0'>Theorem</span> <span style='color:#3b10ff'>medal_ser_deser_identity</span> :
  ser_deser_spec medal medal_serialize medal_deserialize.
<span style='color:#a020f0'>Proof</span>.
  <span style='color:#00008b'>unfold</span> ser_deser_spec.
  <span style='color:#00008b'>unfold</span> medal_deserialize.
  <span style='color:#00008b'>unfold</span> medal_serialize.
  <span style='color:#00008b'>intros</span> m.
  <span style='color:#00008b'>destruct</span> m; <span style='color:#ff0000'>reflexivity</span>.
<span style='color:#a020f0'>Qed</span>.

<span style='color:#a020f0'>Instance</span> <span style='color:#3b10ff'>MedalSerializer</span> : Serializer medal.
<span style='color:#a020f0'>Proof</span>.
<span style='color:#ff0000'>exact</span> {| serialize := medal_serialize;
         deserialize := medal_deserialize;
         ser_deser_identity := medal_ser_deser_identity;
       |}.
<span style='color:#a020f0'>Defined</span>.
</code></pre>
<p>Generalizing this pair deserailizer for arbitrary types <code>A</code> and <code>B</code> comes naturally now that we have chosen better type signatures for serialization and deserialization. Wrapping all three components in a section avoids some boilerplate. Note that there must be a serializer for <code>A</code> and <code>B</code> in order for our <code>A * B</code> serializer to function.</p>
<pre><code><span style='color:#a020f0'>Section</span> <span style='color:#3b10ff'>PairSerializer</span>.
<span style='color:#a020f0'>Variable</span> <span style='color:#3b10ff'>A</span> : <span style='color:#228b22'>Type</span>.
<span style='color:#a020f0'>Variable</span> <span style='color:#3b10ff'>B</span> : <span style='color:#228b22'>Type</span>.
<span style='color:#a020f0'>Variable</span> <span style='color:#3b10ff'>serA</span> : Serializer A.
<span style='color:#a020f0'>Variable</span> <span style='color:#3b10ff'>serB</span> : Serializer B.

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>pair_serialize</span> (p : A * B) : list bool :=
  serialize (fst p) ++ serialize (snd p).

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>pair_deserialize</span> bools 
    : option ((A * B) * list bool) :=
  <span style='color:#228b22'>match</span> deserialize bools <span style='color:#228b22'>with</span>
  | Some (a, bools) =&gt; 
    <span style='color:#228b22'>match</span> deserialize bools <span style='color:#228b22'>with</span>
    | Some (b, bools) =&gt; Some ((a, b), bools)
    | None =&gt; None
    <span style='color:#228b22'>end</span>
  | None =&gt; None
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Theorem</span> <span style='color:#3b10ff'>pair_ser_deser_identity</span> : 
  ser_deser_spec (A * B) pair_serialize pair_deserialize.
<span style='color:#a020f0'>Proof</span>.
  <span style='color:#00008b'>unfold</span> ser_deser_spec.
  <span style='color:#00008b'>intros</span>.
  <span style='color:#00008b'>unfold</span> pair_serialize.
  <span style='color:#00008b'>rewrite</span> app_ass.
  <span style='color:#00008b'>unfold</span> pair_deserialize.
  <span style='color:#00008b'>rewrite</span> ser_deser_identity, ser_deser_identity.
  <span style='color:#00008b'>rewrite</span> &lt;- surjective_pairing.
  <span style='color:#ff0000'>reflexivity</span>.
<span style='color:#a020f0'>Qed</span>.

<span style='color:#a020f0'>Instance</span> <span style='color:#3b10ff'>PairSerializer</span> : Serializer (A * B).
<span style='color:#a020f0'>Proof</span>.
<span style='color:#ff0000'>exact</span> {| serialize := pair_serialize;
         deserialize := pair_deserialize;
         ser_deser_identity := pair_ser_deser_identity;
       |}.
<span style='color:#a020f0'>Defined</span>.

<span style='color:#a020f0'>End</span> <span style='color:#3b10ff'>PairSerializer</span>.
</code></pre>
<p>Note that the variable <code>bools</code> is shadowed several times in this definition. Normally this can complicate code, but in this case it improves clarity because <code>bools</code> always refers to “what’s left to parse”.</p>
<p>Now, we will build a simple (inefficient<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>) serializer/deserializer for a more useful datatype, <code>nat</code>s. The encoding is essentialy the unary representation of the natural number.</p>
<pre><code><span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>nat_serialize</span> (n : nat) : list bool :=
  <span style='color:#228b22'>match</span> n <span style='color:#228b22'>with</span>
  | O =&gt; [false]
  | S n =&gt; [true] ++ (nat_serialize n)
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>nat_deserialize</span> bools : option (nat * list bool) :=
  <span style='color:#228b22'>match</span> bools <span style='color:#228b22'>with</span>
  | true :: bools =&gt; 
    <span style='color:#228b22'>match</span> nat_deserialize bools <span style='color:#228b22'>with</span>
    | None =&gt; None
    | Some (n, bools) =&gt; Some (S n, bools)
    <span style='color:#228b22'>end</span>
  | false :: bools =&gt; Some (O, bools)
  | [] =&gt; None (* Deserializing an empty stream *)
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Theorem</span> <span style='color:#3b10ff'>nat_ser_deser_identity</span> :
  ser_deser_spec nat nat_serialize nat_deserialize.
<span style='color:#a020f0'>Proof</span>.
  <span style='color:#00008b'>unfold</span> ser_deser_spec.
  <span style='color:#00008b'>intros</span> n; <span style='color:#00008b'>induction</span> n; <span style='color:#00008b'>intros</span>.
  - <span style='color:#00008b'>simpl</span>. <span style='color:#ff0000'>reflexivity</span>.
  - <span style='color:#00008b'>simpl</span>.
    <span style='color:#00008b'>rewrite</span> IHn.
    <span style='color:#ff0000'>reflexivity</span>.
<span style='color:#a020f0'>Qed</span>.
</code></pre>
<p>Notice that the information about when to <em>stop</em> deserialization of each element must be encoded into the stream itself. For example with the following <code>nat_serialize</code>, deserialization of <code>nat * nat</code> would become problematic.</p>
<pre><code><span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>nat_serialize_broken</span> (n : nat) : list bool :=
  <span style='color:#228b22'>match</span> n <span style='color:#228b22'>with</span>
  | O =&gt; []
  | S n =&gt; [true] ++ (nat_serialize n)
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>Under this definition, it’s unclear what deserializing <code>[true, true true]</code> as a pair of <code>nat</code>s should return. It could be <code>(0,3)</code>, <code>(1,2)</code>, <code>(2,1)</code> or <code>(3,0)</code>. To remove this ambiguity, the information about when to stop must be encoded in the stream itself in one form or another rather than implicitly, using the end of the stream as a token. Consider the serialized pair of <code>nat</code>s <code>[true, false, true, true, false]</code>, serialized using the not-broken serializer. It is unambigiously <code>(1, 2)</code>. When deserializing it is known precisely when each <code>nat</code> finishes (when <code>false</code> is reached) , and when the pair finishes (when the second <code>nat</code> finishes). This information about the structure of the encoded data plays a crucial part in showing <code>ser_deser_identity</code>.</p>
<h2 id="list-serialization">List Serialization</h2>
<p>When serializing lists (or any variable sized collection) we need to make sure to include some information about the structure in the serialized stream. Imagine we did not do this, and we serialized a pair of lists into the byte stream. We would get an encoding which looks like the figure below. As you can see, it’s impossible to tell where one list stops and the next begins just by looking at the stream.</p>
<p><img src="list_broken.png" /></p>
<p>This serializer is broken for the same reason as the broken <code>nat</code> serializer, the information in a serialized object must be entirely contained within the bitstream. Note that we don’t run into this problem with any collection of fixed size, like a pair or vector. It is clear when to stop deserializing a <code>Vec 5</code> because 5 elements have been deserialized. In this case, the information about the shape of the data in this case is encoded in the type, and since the type is known to the serializer and the deserializer, it does not need to be encoded in the bitstream.</p>
<p>Let’s start with solving this problem by including a “continue” bit before every element. If it is true an element follows, and if it is false, the end of the list has been reached. This appears as follows:</p>
<p><img src="list_interleaved.png" /></p>
<p>Let’s see what this looks like in code.</p>
<pre><code><span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>list_serialize_inter</span> (l : list A) : list bool :=
  <span style='color:#228b22'>match</span> l <span style='color:#228b22'>with</span>
  | [] =&gt; [false]
  | h :: t =&gt; [true] ++ serialize h ++ list_serialize_inter t
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>With this scheme, deserialization again proves to be difficult. In the definiton below, because <code>bools_after_elem</code> is not a syntactic subterm of <code>bools</code>, the termination checker refuses to accept this definition. In fact, the definition <em>does</em> terminate, since <code>bools_after_elem</code> is a strict suffix of <code>bools</code>, but the type system does not see this. An attempted definition is given below:</p>
<pre><code><span style='color:#a020f0'>Fail</span> <span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>list_deserialize_inter</span>
  (bools: list bool) : option (list A * list bool) :=
  <span style='color:#228b22'>match</span> bools <span style='color:#228b22'>with</span>
  | [] =&gt; None
  | false :: bools =&gt; Some ([], bools)
  | true :: bools =&gt;
    <span style='color:#228b22'>match</span> deserialize bools <span style='color:#228b22'>with</span>
    | None =&gt; None
    | Some (a, bools_after_elem) =&gt;
      <span style='color:#228b22'>match</span> list_deserialize_em bools_after_elem <span style='color:#228b22'>with</span>
      | None =&gt; None
      | Some (tail, bools_after_list) =&gt;
          Some (a :: tail, bools_after_list)
      <span style='color:#228b22'>end</span>
    <span style='color:#228b22'>end</span>
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>It is intuitively impossible to define this deserialization function without using general recursion. To solve this recursion problem, we can take the same information encoded in the continuation bits and move it to the front of the list’s encoding in the form of a size. Then the rest of the deserializer can recurse on the number of elements remaining.</p>
<p><img src="list_front.png" /></p>
<p>Programmatically,</p>
<pre><code><span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>list_serialize_elts</span> (l : list A) : list bool :=
  <span style='color:#228b22'>match</span> l <span style='color:#228b22'>with</span>
  | [] =&gt; []
  | h :: t =&gt; serialize h ++ list_serialize_elts t
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>list_serialize</span> (l : list A) : list bool :=
  nat_serialize (length l) ++ list_serialize_elts l.

<span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>list_deserialize_elts</span> (size : nat) (bools : list bool)
      : option (list A * list bool) :=
  <span style='color:#228b22'>match</span> size <span style='color:#228b22'>with</span>
  | O =&gt; Some ([], bools)
  | S size =&gt; 
    <span style='color:#228b22'>match</span> deserialize bools <span style='color:#228b22'>with</span>
    | None =&gt; None
    | Some (n, bools) =&gt;
      <span style='color:#228b22'>match</span> list_deserialize_elts size bools <span style='color:#228b22'>with</span>
      | None =&gt; None
      | Some (tail, bools) =&gt; Some (n :: tail, bools)
      <span style='color:#228b22'>end</span>
    <span style='color:#228b22'>end</span>
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>list_deserialize</span> bools :=
  <span style='color:#228b22'>match</span> deserialize bools <span style='color:#228b22'>with</span>
  | None =&gt; None
  | Some (size, bools) =&gt; list_deserialize_elts size bools
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>This gives a definition which we can define with only structural recursion just by moving the information around. It’s worth noting that because the size information is grouped together instead of spread apart, it would be much easier to make the encoding format more efficient by swapping in a more efficient <code>nat</code> serializer. The only property lost with this encoding is that it is now impossible to reason about any tail of the list in isolation, the concept of a size must also be considererd.</p>
<h2 id="binary-trees">Binary Trees</h2>
<p>To continue exploring this idea of serializing shape, we need to look at a more complicated data structure such as a binary tree. Our definition of a binary tree is straightforward:</p>
<pre><code><span style='color:#a020f0'>Inductive</span> <span style='color:#3b10ff'>tree</span>: <span style='color:#228b22'>Type</span> := 
| leaf : tree
| node : A -&gt; tree -&gt; tree -&gt; tree.
</code></pre>
<p>Just as with lists, there are two ways of serializing trees: interleaved and up front.</p>
<p>For the interleaved shape tree serializer, the concept of a “path” is needed. A path is simply the list of directions taken from the root to reach some node. We’ll use <code>true</code> to represent left and <code>false</code> to represent right. These directions are stored with the head at the top of the tree. Below is the path <code>[true, false]</code>.</p>
<p><img src="path.png" /></p>
<p>Using the concept of a path, the position and data of any node can be serialized. When this is done for all nodes in the tree, all information captured by the original data structure has been encoded.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<p>Even though an interleaved structure is impossible to deserialize without general recursion, using an interleaved structure is still possible if there is just enough information up front to recurse on. The number of nodes in the tree provides a nice metric. Our serializer will not truly be interleaved since we require this header, but information about the shape will still be interleaved in the encoding.</p>
<p>The encoding using an interleaved structure looks like this:</p>
<p><img src="tree_interleaved.png" /></p>
<p>Serialization is performed as follows:</p>
<pre><code><span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>tree_size</span> (t : tree A) : nat :=
  <span style='color:#228b22'>match</span> t <span style='color:#228b22'>with</span>
  | leaf =&gt; 0
  | node _ l r =&gt; 1 + tree_size l + tree_size r
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>tree_serialize_subtree_inter</span> 
    (t: tree A) (path: list bool) :=
  <span style='color:#228b22'>match</span> t <span style='color:#228b22'>with</span>
    | leaf =&gt; []
    | node a l r =&gt; serialize path ++ serialize a
      ++ tree_serialize_subtree_inter l (path ++ [true])
      ++ tree_serialize_subtree_inter r (path ++ [false])
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>tree_serialize_inter</span> (t: tree A) : list bool :=
  nat_serialize (tree_size t) ++ 
  tree_serialize_subtree_inter t [].
</code></pre>
<p>Deserialization is more complicated. As elements are parsed, they are inserted into the tree structure parsed already. The insertion function used is not particularly robust, however during deserialization as long as any given node is preceded by all of its parents no issues arise. This is the case with a preorder traversal, and also with other traversals including BFS, so it meets our needs.</p>
<pre><code><span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>tree_insert</span> (into t: tree A)(path: list bool): tree A :=
  <span style='color:#228b22'>match</span> into <span style='color:#228b22'>with</span>
  | leaf =&gt; t
  | node a l r =&gt;
      <span style='color:#228b22'>match</span> path <span style='color:#228b22'>with</span>
      | [] =&gt; t (* not supported *)
      | true :: path =&gt; node a (tree_insert l t path) r
      | false :: path =&gt; node a l (tree_insert r t path)
      <span style='color:#228b22'>end</span>
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>tree_deserialize_inter_impl</span>
         (remaining : nat) (root : tree A) (bools : list bool)
         : option (tree A * list bool) :=
  <span style='color:#228b22'>match</span> remaining <span style='color:#228b22'>with</span>
  | S n =&gt;
    <span style='color:#228b22'>match</span> deserialize bools <span style='color:#228b22'>with</span>
    | None =&gt; None
    | Some (path, bools) =&gt;
      <span style='color:#228b22'>match</span> deserialize bools <span style='color:#228b22'>with</span>
      | None =&gt; None
      | Some (a, bools) =&gt;
        tree_deserialize_inter_impl
          n
          (tree_insert root (node a leaf leaf) path)
          bools
      <span style='color:#228b22'>end</span>
    <span style='color:#228b22'>end</span>
  | O =&gt; Some (root, bools)
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>tree_deserialize_inter</span> bools :=
  <span style='color:#228b22'>match</span> nat_deserialize bools <span style='color:#228b22'>with</span> 
  | Some (size, bools) =&gt; 
        tree_deserialize_inter_impl size leaf bools
  | None =&gt; None
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>Because of this concept of a path, which is a global address of any particular node, reasoning about a tree becomes much more difficult. In particular, we must now prove that every insertion is made on a leaf of the tree so it does not overwrite data or fall off the end.</p>
<pre><code><span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>leaf_insertable</span> (into: tree A)(path: list bool): <span style='color:#228b22'>Prop</span> :=
  <span style='color:#228b22'>match</span> into <span style='color:#228b22'>with</span>
  | leaf =&gt; 
    (* Only <span style='color:#228b22'>if</span> the path and tree run out at the same time
       should we be able to insert *)
      <span style='color:#228b22'>match</span> path <span style='color:#228b22'>with</span>
      | [] =&gt; True
      | _ =&gt; False
      <span style='color:#228b22'>end</span>
  | node a l r =&gt;
      <span style='color:#228b22'>match</span> path <span style='color:#228b22'>with</span>
      | [] =&gt; False
      | true :: path =&gt; (leaf_insertable l path)
      | false :: path =&gt; (leaf_insertable r path)
      <span style='color:#228b22'>end</span>
  <span style='color:#228b22'>end</span>.
</code></pre>
<h3 id="up-front-tree-serializer">Up-front Tree Serializer</h3>
<p>Alternatively, the structure may be recorded at the beginning and then filled in as the tree is parsed. We can now reason about a tree as both it’s shape as the type <code>tree unit</code>, and it’s elements as the type <code>list A</code>.</p>
<p>This technique requires serialization and deserialization to be a two step process, which has the advantage of better mapping to the information stored in the tree (shape and element data) but also the disadvantage of being more complicated.</p>
<p>The shape is encoded similarly to HTML with three symbols:</p>
<ul>
<li><code>[true; true]</code>: The beginning of a <code>node</code></li>
<li><code>[true; false]</code>: The end of a <code>node</code></li>
<li><code>[false]</code>: A leaf node</li>
</ul>
<p>Each <code>node</code> requieres exactly two subtrees between its start and end marker. Storing the shape as <code>tree unit</code> works because <code>unit</code> contains no information, so <code>tree unit</code> only contains the information that the <code>tree</code> portion of <code>tree A</code> describes, which is the shape. Since we record this shape in a preorder traversal, the elements are also encoded in the same order, which makes it easy to marry the two together.</p>
<p>A visual representation of this encoding:</p>
<p><img src="tree_front.png" /></p>
<p>And in code:</p>
<pre><code><span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>tree_serialize_shape</span> (t : tree A) : list bool :=
  <span style='color:#228b22'>match</span> t <span style='color:#228b22'>with</span>
  | leaf =&gt; [false]
  | node _ l r =&gt; [true; true] ++ tree_serialize_shape l ++
                  tree_serialize_shape r ++ [true; false]
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>tree_serialize_data_preorder</span> (t : tree A) : list bool :=
  <span style='color:#228b22'>match</span> t <span style='color:#228b22'>with</span>
  | leaf =&gt; [] (* No data contained within leaf nodes *)
  | node a l r =&gt; serialize a ++
                  tree_serialize_data_preorder l ++
                  tree_serialize_data_preorder r
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>tree_serialize_front</span> (t: tree A) : list bool :=
  tree_serialize_shape t ++ tree_serialize_data_preorder t.

<span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>tree_deserialize_shape</span> 
    (bools: list bool) (progress: list (list (tree unit)))
    : option (tree unit * list bool) :=
  <span style='color:#228b22'>match</span> bools <span style='color:#228b22'>with</span>
  | false :: bools =&gt; 
    <span style='color:#228b22'>match</span> progress <span style='color:#228b22'>with</span>
    | [] =&gt; Some (leaf, bools)
    | level :: progress =&gt;
        tree_deserialize_shape
          bools
          ((leaf :: level) :: progress)
    <span style='color:#228b22'>end</span>
  | true :: true :: bools =&gt;
        tree_deserialize_shape bools ([] :: progress)
  | true :: false :: bools =&gt;
    <span style='color:#228b22'>match</span> progress <span style='color:#228b22'>with</span>
    | [] =&gt; None (* <span style='color:#228b22'>end</span> without a beginning *)
    | level :: [] =&gt; 
      <span style='color:#228b22'>match</span> level <span style='color:#228b22'>with</span>
      | [r; l] =&gt; Some (node tt l r, bools)
      | _ =&gt; None
      <span style='color:#228b22'>end</span>
    | level :: parent :: progress =&gt;
      <span style='color:#228b22'>match</span> level <span style='color:#228b22'>with</span>
      | [r; l] =&gt;
        tree_deserialize_shape
          bools
          ((node tt l r :: parent) :: progress)
      | _ =&gt; None
      <span style='color:#228b22'>end</span>
    <span style='color:#228b22'>end</span>
  | _ =&gt; None
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Fixpoint</span> <span style='color:#3b10ff'>tree_deserialize_front_elts</span>
    (shape : tree unit) (bools : list bool) 
    : option (tree A * list bool) :=
  <span style='color:#228b22'>match</span> shape <span style='color:#228b22'>with</span>
  | leaf =&gt; Some (leaf, bools)
  | node _ l r =&gt;
    <span style='color:#228b22'>match</span> deserialize bools <span style='color:#228b22'>with</span>
    | None =&gt; None
    | Some (a, bools) =&gt;
      <span style='color:#228b22'>match</span> tree_deserialize_front_elts l bools <span style='color:#228b22'>with</span>
      | None =&gt; None
      | Some (l, bools) =&gt; 
        <span style='color:#228b22'>match</span> tree_deserialize_front_elts r bools <span style='color:#228b22'>with</span>
        | None =&gt; None
        | Some (r, bools) =&gt; Some (node a l r, bools)
        <span style='color:#228b22'>end</span>
      <span style='color:#228b22'>end</span>
    <span style='color:#228b22'>end</span>
  <span style='color:#228b22'>end</span>.

<span style='color:#a020f0'>Definition</span> <span style='color:#3b10ff'>tree_deserialize_front</span> (bools : list bool)
    : option (tree A * list bool) :=
  <span style='color:#228b22'>match</span> tree_deserialize_shape bools [] <span style='color:#228b22'>with</span>
  | None =&gt; None
  | Some (shape, bools) =&gt;
        tree_deserialize_front_elts shape bools
  <span style='color:#228b22'>end</span>.
</code></pre>
<p>Because of the more recursive nature of the encoding, reasoning is significantly easier. We can consider any portion of the shape in isolation from all others because there are no ties to any global state.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It’s worth noting that possible encodings for a given type are restricted by information dependencies within that type. Imagine we encode a list as follows:</p>
<p><img src="list_size_end.png" /></p>
<p>Since the size of the list is at the end, rather than at the beginning, information about how to deserialize the structure isn’t known until its too late. Similarly, we couldn’t put the size anywhere in the middle (say after the first element), because of the possibility of an empty list. In other words, before deserializing each element, we need to know that it actually is an element of the list, and not some other data coming after the list.</p>
<p>This is why the interleaved list serializer is able to work. Right before each element is deserialized, we mark that the list continues with the continue bit.</p>
<p>This is also why the tree serializers are able to encode the shape at the front or the end. In both cases, the size is known so deserializing additional elements is justified. The question of how to arrange these elements can be reasoned about independantly of the elements themselves, therefore the shape of the tree can be encoded without regard to where the element data is located.</p>
<p>One might expect to be able to speculatively parse elements of the bitstream and stop when an invalid element is reached. But this requires that we don’t accidentily intrepret whatever came after in the bit stream as an element. If the encoding of different types are guaranteed to not overlap, then this would be possible. But in our model, serializers can choose arbitrary encodings, so this is not possible.</p>
<p>Beyond practical necesity, serialization can be used as a forcing function to understand the information contained within data structures. By requiring a well defined format, the information contained in that structure may be deduced and formalized. For example, a list needs to have a length, and a tree needs to have a shape. From there, the encoding of this information is flexible, although some encodings are easier to work with than others.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A linked list of booleans is not computationally efficient, and could be replaced with another more sensible structure such as a stream of bytes.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>It’s worth noting that this representation could be made more efficient by recording locations relative to the previous node instead of absolute ones. However, this fact does not significantly change how hard it is to reason aboout the tree. Recording relative locations would allow us to reason about subtrees instead of parts of some tree, but we still must reason about insertions.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
